<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"     "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- MyBatis 사용 시 SQL을 관리하는 파일 -->
<!-- 매퍼 파일안에 있는 쿼리들은 물리적인 파일에 의해서 관리가 되는 것이 아니라 namespace 속성에 의해서 관리된다. -->
<mapper namespace="test">
	<!-- 원래는 c:.. 식으로 별칭을 하는데.. 별칭을 저렇게 설정하는 건 마이바이티스만의 설정임. -->
	<!-- 그리고, 설정한 패키지하위의 구문들은 어느 파일에서 작성된 구문인지 물리적으로 구분할 수 없다. 별칭(네임스페이스)으로 구분한다. -->
	<!-- 매퍼 파일안에 있는 쿼리들은 물리적인 파일에 의해서 관리가 되는것이 아니라, namespace속성에 의해서 관리된다. -->
	
	<insert id="m1">
		insert into tblMyBatis values (mybatis_seq.nextval, 30, '삼십')
	</insert>

	<delete id="m2" parameterType="Integer">
		delete from tblMyBatis where seq = #{seq}
		<!-- 지금까지의 ?는, 오라클에서 제공한 표현이었다. 이젠, 바티스가 제공하는 표현을 사용한다. -->
		<!-- 식별자의 이름은 강제성이 없다. 지금은 하나밖에 없기때문에, 무얼써도 반응해주지만.. 가독성을 위해, 동일하게 적어준다. -->
	</delete>
	
	<update id="m3" parameterType="String">
		update tblMyBatis set num = num+100 where str = #{str} 
	</update>
	
	<!-- <insert id="m4" parameterType="com.test.spring.MyBatisDTO"> -->
	<insert id="m4" parameterType="dto">
	<!-- mybatis.xml 에서 별칭을 설정하고 왔다. -->
		insert into tblMyBatis values (mybatis_seq.nextval, #{num}, #{str})
		<!-- 내부적으로 게터를 쓴다. 따라서, dto에 있는 멤버의 이름과 동일하게 작성해야 한다. -->
	</insert>
	
	<update id="m5" parameterType="map">
		<!-- 누가만들었던 말던, java.lang 에서 정의된 클래스가 아니라면, 풀네임을 적어야한다.  -->
		update tblMyBatis set num = #{num}, str = #{str} where seq = #{seq}
		<!-- 또한 동일하게, 해쉬맵의 키값을 사용한다. -->
	</update>
	
	<!-- 반환값 -->
	<select id="m6" resultType="Integer">
		select sum(num) from tblMyBatis
	</select>
	<select id="m7" resultType="String">
		select str from tblMyBatis where seq = 21
	</select>
	<select id="m8" resultType="dto">
		select * from tblMyBatis where seq = 21
		<!-- 빈프로퍼티로우매퍼에 대한 언급이 1도 없다. 다 자동. 단, 당연하게도, 이 혜택을 받기 위해선, 컬럼명과 dto의 세터이름이 동일해야한다. -->
	</select>
	
	<!-- 리스트로 묶어주는건 selectList()의 역할. -->
	<!-- 우리가 알려주는 '반환값 타입'은, 반환되는 값의 타입이다. Integer! -->
	<!-- 전체 프레임의 타입? ㄴㄴ! 반한되는 레코드의 타입! -->
	<select id="m9" resultType="Integer">
		select num from tblMyBatis
	</select>
	<select id="m10" resultType="dto">
		select * from tblMyBatis
	</select>
	<!-- m10과 m8을 구분할 수 없다. 저걸 구분할 수 있는 근거는, dao에서 호출한 메소드가 selectOne인가 selectList인가로 나뉜다.-->
	
	<!-- 인자값+반환값 -->
	<select id="m11" resultType="dto" parameterType="String">
		select * from tblMyBatis  
		
		<!-- select * from tblMyBatis order by seq #{order} -->
			<!-- -> select * from tblMyBatis order by seq 'asc' -->
		<!-- select * from tblMyBatis order by seq ${order} -->
			<!-- select * from tblMyBatis order by seq asc -->
				<!-- 하지만, asc를 그냥 문자가 아니라, 어떤 데이터를 가르키는(시퀸스객체, 테이블 혹은 다른 무언가) 식별자로 인식해서, "그런 객체는 없어!" 라면서 에러를 냄. -->
				
				<!-- 선생님의 도움을 얻어서.. 이렇게 하면 된다. -->
				order by seq ${_parameter}
			
			
		
		<!-- 동적쿼리 -->
		<!-- 인자값을 가르키는 예약어, _parameter -->
		<!-- <if test="_parameter.equals('asc')">
			order by seq asc
		</if>
		<if test="_parameter.equals('desc')">
			order by seq desc
		</if> -->
	</select> 
	
	<select id="m12" resultType="dto" parameterType="map">
		select * from tblMyBatis
		
		<!-- where 컬럼 like '%검색어%' -->
		
		<!-- 데이터를 바인딩(치환하는 행위를 일컫음)을 할 때는, #{} -->
		<!-- 식별자를 ''									  , ${} -->			
			<!-- #{}는 데이터를 바인딩할 때를 상정하고 만들어졌기 때문에, 바인딩할 때 ''가 양옆에 붙는다. 하여 #{word}는 '십'으로 바뀌지만, -->
			<!-- #{column}은 'str'이 된다. 컬럼명자리에 식별자가 아닌 문자열이 들어가서, 에러. -->
			<!-- 반대로 word를 ${}로 해도, 에러. -->
			
			<!-- 식별자로서 바인딩을 하면, 만약 바인딩 결과가 result 였다면, result라는 컬럼이든, 시퀀스 든, 오라클서버안에서 그 식별자이름에 매핑되는 걸 찾는다. -->
			
			
		
		where ${column} like '%'||#{word}||'%' <!-- ''안에 감싸진 순간, 정적이 되므로 -->
	</select>
	
	
</mapper>




























    